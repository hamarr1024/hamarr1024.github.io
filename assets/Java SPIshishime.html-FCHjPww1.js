import{_ as e,o as c,c as o,d}from"./app-ChDUwo2y.js";const a={},s=d("<p>一句话总结: Java SPI是 <code>JDK内置</code>的 <code>基于配置文件</code>和 <code>面向接口</code>的动态加载具体服务实现类的编程模式。 拆开来说主要有以下2点</p><ul><li>面向接口编程: service provider interface, 它是面向接口的，不同服务提供者通过实现同一个接口，对服务消费者提供统一的访问方式。反过来，因为服务消费者是面向接口获取服务，那么可以无感地替换掉接口实现类。说到底，是 <code>依赖倒置</code>和 <code>里氏替换</code>设计原则的应用。</li><li>基于约定和配置：Java SPI约定, 服务的接口，必须定义为在类路径下META-INF/services目录下的文件中，且文件名就是接口的全限定名，文件内容就是接口实现类的全限定名，有多个接口实现类时使用换行符隔开</li></ul><p>事实上，我认为SPI主要体现了 <code>依赖倒置</code>和 <code>里氏替换</code>的设计原则，通过面向接口编程+基于配置或约定，将 <code>抽象功能</code>和 <code>具体实现</code>做了解耦，是进行模块化软件开发的一个基础。</p><p>最后, 我认为只要是体现了 <code>面向接口</code>和 <code>基于约定和配置</code>去动态的加载服务实现类思想的设计，都属于SPI机制，并不仅仅局限在Java中。</p>",4),t=[s];function i(r,_){return c(),o("div",null,t)}const n=e(a,[["render",i],["__file","Java SPIshishime.html.vue"]]);export{n as default};
