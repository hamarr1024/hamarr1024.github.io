import{_ as e,o,c as a,a as t}from"./app-T0ug101R.js";const c="/assets/1707844889720-3tbjZwQJ.png",s={},h=t('<h2 id="平衡的概念" tabindex="-1"><a class="header-anchor" href="#平衡的概念" aria-hidden="true">#</a> 平衡的概念</h2><p>当节点数量固定时，左右子树的高度越接近，这颗二叉树就越平衡，同时整棵树的高度就越低</p><p><img src="'+c+'" alt="1707844889720"></p><blockquote><p>二叉搜索树为什么需要平衡？</p><p>对于一颗BST，无论是添加还是删除一个节点，都必须先进行查询，查询到之后进行的操作都是O(1)的，所以这些操作的时间复杂度主要取决于查询的时间复杂度，对于一颗高度为h的BST, 平均时间复杂度是O(h), 因此我们的目标是尽量通过调整节点的相对位置来减小h，其实也就是尽量使得BST趋于平衡</p></blockquote><h2 id="性能和平衡的权衡" tabindex="-1"><a class="header-anchor" href="#性能和平衡的权衡" aria-hidden="true">#</a> 性能和平衡的权衡</h2><p>任何一颗BST都可以调整成一颗完全二叉树，此时树的高度是最低的，查询的性能也是最好的。</p><p>然而，天下没有免费的午餐，调整BST趋于平衡也是有一定的开销的，每次插入或者删除一个元素如果都要调整BST为一颗完全二叉树带来的开销可能远远超过操作本身的开销。因此我们的目标是“用尽量少的调整次数使得BST达到适度平衡&quot;</p><blockquote><p>怎么去衡量 <code>适度</code> 呢？有没有定量的方式？</p><p>比如，对于一颗BST，我们定义任意一个节点的左右子树的高度差，通过这个高度差来衡量这个节点为根节点的BST的 <code>平衡程度</code> 这个平衡程度也有个名字，叫 <code>平衡因子</code></p></blockquote><h2 id="常见的平衡bst" tabindex="-1"><a class="header-anchor" href="#常见的平衡bst" aria-hidden="true">#</a> 常见的平衡BST</h2><ol><li>AVL树</li><li>红黑树</li></ol><p>这两种也称为自平衡的BST，就是在添加、搜索操作后可以自动调整为平衡状态。</p>',11),r=[h];function d(i,n){return o(),a("div",null,r)}const l=e(s,[["render",d],["__file","4.pinghengerchasousuoshu.html.vue"]]);export{l as default};
